#!env perl6
use v6;
use LibXML;
use LibXML::Document;
use LibXML::Element;
use LibXML::Raw::Gen;

constant Gen = LibXML::Raw::Gen;

my subset EnumDefElem of LibXML::Element where .tagName eq 'enum';
my subset FileDefElem of LibXML::Element where .tagName eq 'file';
my subset FieldDefElem of LibXML::Element where .tagName eq 'field';
my subset FunctionDefElem of LibXML::Element where .tagName eq 'function';
my subset StructDefElem of LibXML::Element where .tagName eq 'struct';
my subset TypeDefElem of LibXML::Element where .tagName eq 'typedef';

sub gen-dir(Str:D $ns) {
    with $*SPEC.catdir('lib', $ns, 'Raw', 'Gen') {
        mkdir $_;
        $_;
    }
}

sub write-file(Gen::File:D $module, :$mod='LibXML', :$lib='XML2') {
    my $module-name = $module.name;
    my $path =  $*SPEC.catfile( gen-dir($mod), $module-name ~ '.rakumod');
    {
        my $*OUT = open $path, :w;
        say 'use v6;';
        say "# -- DO NOT EDIT --";
        say "# generated by: $*PROGRAM-NAME";
        say '';
        say "unit module {$mod}::Raw::Gen::$module-name;";
        say "# $_:" with $module.summary;
        say "#    $_" with $module.description;
        if $mod eq 'LibXML' {
            say 'use ' ~ $mod ~ '::Raw::Defs :$XML2, :xmlCharP;';
        }
        else {
            say 'use LibXML::Raw::Defs :xmlCharP;';
            say 'use ' ~ $mod ~ '::Raw::Defs :$XML2;';
        }

        for $module.enums.sort {
            my $name = .key;
            say '';
            say "enum $name is export (";
            for .value.pairs.sort {
                say "    {.key} => {.value},";
            }
            say ');';
        }

        for $module.typedefs {
            my $name = .name;
            my $type = .type;
            $type = 'Pointer'
                if $type ~~ /'struct'/;
        }

        for $module.structs {
            my $name = .name;
            my $repr = .fields ?? 'CStruct' !!  'CPointer';
            say '';
            say "class $name is repr('$repr') \{";
            for .fields {
                my $name = .name;
                my $type = .type;
                my $info = .Str.trim with .info;
                $info = ' # ' ~ $info if $info;
                say "    has $type \$\.$name;$info";
            }
            say '' if .fields && .subs;
            for .subs.sort(*.name).list {
                say "    " ~ .Str;
            }
            say '' if .subs && .methods;
            for .methods.sort(*.name).list {
                say "    " ~ .Str(:method);
            }
            say '}';
        }
        say '' if $module.subs;
        for $module.subs.list {
            say .Str;
        }
    }
    $*ERR.print: '!';

}

sub process-files(Str:D $xpath) {
    for $*Root{$xpath} -> FileDefElem $_ {
        my $name = .Str with .<@name>;
        my $summary = .<summary>[0].textContent;
        my $description = .<description>[0].textContent;
        my Gen::File $file .= new: :$name, :$summary, :$description;
        %*Files{$file.name} = $file;
        $*ERR.print('.');
    }
}

sub process-enums(Str:D $xpath) {
    for $*Root{$xpath} -> EnumDefElem $_ {
        my $name = .Str with .<@name>;
        my $type = .Str with .<@type>;
        my $file-name = .Str with .<@file>;
        my $value = .Str with .<@value>.Int;

        my $file = %*Files{$file-name} //= Gen::File.new: :name($file-name);
        $file.enums{$type}{$name} = $value;
        $*ERR.print('+');
    }
}

sub process-struct-fields(StructDefElem:D $_, Str:D $xpath, Gen::Struct :$struct!, ) {
    for .{$xpath} -> FieldDefElem $_ {
        my $name = .Str with .<@name>;
        my $type = .Str with .<@type>;
        my $info = .Str with .<@info>;

        my Gen::Field $field .= new: :$name, :$type, :$info;
        $struct.fields.push: $field;
        $*ERR.print('<');
    }
}

sub process-functions(Str:D $xpath, :$lib = 'XML2') {
    for $*Root{$xpath} -> FunctionDefElem $_ {
        my $name = .Str with .<@name>;
        my $type = .Str with .<@type>;
        my $file-name = .Str with .<@file>;
        my $info = .Str with .<info>;

        my Gen::Field ($return, @args);
        with .<return>[0] {
            my $type = .Str with .<@type>;
            my $info = .Str with .<@info>;
            $return .= new: :$type, :$info;
        }
        with .<arg> {
            @args = .map: {
                my $name = .Str with .<@name>;
                my $type = .Str with .<@type>;
                my $info = .Str with .<@info>;
                Gen::Field.new: :$name, :$type, :$info;
            }
        }

        my Gen::Function $function .= new: :$name, :$return, :$lib, :@args;

        my $method-type = .type with @args[0];
        my $return-type = .type with $return;
        my $method-struct = %*Structs{$_} with $method-type;
        my $return-struct = %*Structs{$_} with $return-type;
        with $method-struct {
            .methods.push: $function;
        }
        else {
            with $return-struct {
                .subs.push: $function;
            }
            else {
                my $file = %*Files{$file-name} //= Gen::File.new: :name($file-name);
                $file.subs.push: $function;
            }
        }
        $*ERR.print('>');
    }
}

sub process-structs(Str:D $xpath) {
    for $*Root{$xpath} -> StructDefElem $_ {
        my $name = .Str with .<@name>;
        my $file-name = .Str with .<@file>;

        my $file = %*Files{$file-name} //= Gen::File.new: :name($file-name);
        my Gen::Struct $struct .= new: :$name;
        process-struct-fields($_, 'field', :$struct);
        %*Structs{$name} //= $struct;
        $file.structs.push: $struct;
        $*ERR.print('*');
    }
}

sub process-typedefs(Str:D $xpath) {
    for $*Root{$xpath} -> TypeDefElem $_ {
        my $name = .Str with .<@name>;
        unless $name.ends-with('Ptr') {
            my $type = .Str with .<@type>;
            my $file-name = .Str with .<@file>;

            my $file = %*Files{$file-name} //= Gen::File.new: :name($file-name);
            my Gen::Typedef $typedef .= new: :$name, :$type;
            $file.typedefs.push: $typedef;
            $*ERR.print('T');
        }
    }
}

sub MAIN(Str $api?, Str :$mod='LibXML', Str :$lib='XML2') {
    my LibXML::Document:D $doc .= parse: :file($api // LibXML::Raw::Gen.source);
    my LibXML::Element:D $*Root = $doc.root;
    my Gen::File %*Files;
    my Gen::Struct %*Structs;
    
    my %api = $*Root.childNodes.Hash;

    process-files('files/file');
    process-enums('symbols/enum');
    process-structs('symbols/struct');
    process-typedefs('symbols/typedef');
    process-functions('symbols/function', :$lib);

    write-file($_, :$mod, :$lib) for %*Files.values.sort(*.name);
}
